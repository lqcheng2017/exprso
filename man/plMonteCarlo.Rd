% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/7.3-plMonteCarlo.R
\name{plMonteCarlo}
\alias{plMonteCarlo}
\title{Monte Carlo Cross-Validation}
\usage{
plMonteCarlo(array, B = 10, ctrlSS, ctrlFS, ctrlGS, save = FALSE)
}
\arguments{
\item{array}{Specifies the \code{ExprsArray} object to undergo cross-validation.}

\item{B}{A numeric scalar. The number of times to \code{split} the data.}

\item{ctrlSS}{Arguments handled by \code{\link{ctrlSplitSet}}.}

\item{ctrlFS}{A list of arguments handled by \code{\link{ctrlFeatureSelect}}.}

\item{ctrlGS}{Arguments handled by \code{\link{ctrlGridSearch}}.}

\item{save}{A logical scalar. Toggles whether to save randomly split
training and validation sets.}
}
\value{
An \code{\link{ExprsPipeline-class}} object.
}
\description{
Perform Monte Carlo style cross-validation.
}
\details{
Analogous to how \code{\link{plGrid}} manages multiple \code{build} and
 \code{predict} tasks, \code{plMonteCarlo} effectively manages multiple
 \code{\link{plGrid}} tasks.

Specifically, \code{plMonteCarlo} will call the provided \code{split}
 function (via \code{ctrlSS}) some \code{B} times, performing all
 feature selection tasks (listed via \code{ctrlFS}) on each split
 training set, and executing \code{plGrid} (via \code{ctrlGS}) on the
 training set. We hope future implementations will accomodate
 other \code{ctrlGS} functions beyond \code{plGrid}.

To perform multiple feature selection tasks, supply a list of multiple
 \code{\link{ctrlFeatureSelect}} argument wrappers to \code{ctrlFS}.
 To reduce the results of \code{plMonteCarlo} to a single performance metric,
 feed the returned \code{ExprsPipeline} object through
 \code{\link{calcMonteCarlo}}.

Note that \code{plGrid} uses \code{\link{plCV}} to calculate the "inner"
 cross-validation accuracy. Depending on the use case, may not represent
 the most appropriate choice. We hope future implementations will accomodate
 other \code{ctrlGS} functions beyond \code{plGrid}.
}
\examples{
\dontrun{
require(golubEsets)
data(Golub_Merge)
array <- arrayEset(Golub_Merge, colBy = "ALL.AML", include = list("ALL", "AML"))
array <- modFilter(array, 20, 16000, 500, 5) # pre-filter Golub ala Deb 2003
array <- modTransform(array) # lg transform
array <- modNormalize(array, c(1, 2)) # normalize gene and subject vectors
ss <- ctrlSplitSet(func = "splitStratify", percent.include = 67, colBy = NULL)
fs <- list(ctrlFeatureSelect(func = "fsStats", top = 0, how = "t.test"),
           ctrlFeatureSelect(func = "fsPrcomp", top = 50))
gs <- ctrlGridSearch(func = "plGrid", how = "buildSVM", top = c(2, 3, 4), fold = 10,
                     kernel = c("linear", "radial"), cost = 10^(-3:3), gamma = 10^(-3:3))
boot <- plMonteCarlo(array, B = 3, ctrlSS = ss, ctrlFS = fs, ctrlGS = gs)
}
}
\seealso{
\code{\link{plCV}}, \code{\link{plGrid}}, \code{\link{plMonteCarlo}}, \code{\link{plNested}}
}

