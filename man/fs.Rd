% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/5.1-fs-binary.R, R/5.3-doMulti.R
\docType{methods}
\name{fs}
\alias{fs}
\alias{fsEbayes}
\alias{fsEbayes,ExprsBinary-method}
\alias{fsMrmre}
\alias{fsMrmre,ExprsBinary-method}
\alias{fsPathClassRFE}
\alias{fsPathClassRFE,ExprsBinary-method}
\alias{fsPenalizedSVM}
\alias{fsPenalizedSVM,ExprsBinary-method}
\alias{fsPrcomp}
\alias{fsPrcomp,ExprsBinary-method}
\alias{fsSample}
\alias{fsSample,ExprsBinary-method}
\alias{fsSample,ExprsMulti-method}
\alias{fsStats}
\alias{fsStats,ExprsBinary-method}
\alias{fsStats,ExprsMulti-method}
\title{Perform Feature Selection}
\usage{
fsSample(object, ...)

fsStats(object, ...)

fsPrcomp(object, ...)

fsPenalizedSVM(object, ...)

fsPathClassRFE(object, ...)

fsEbayes(object, ...)

fsMrmre(object, ...)

\S4method{fsSample}{ExprsBinary}(object, probes, ...)

\S4method{fsStats}{ExprsBinary}(object, probes, how = "t.test", ...)

\S4method{fsPrcomp}{ExprsBinary}(object, probes, ...)

\S4method{fsPenalizedSVM}{ExprsBinary}(object, probes, ...)

\S4method{fsPathClassRFE}{ExprsBinary}(object, probes, ...)

\S4method{fsEbayes}{ExprsBinary}(object, probes, ...)

\S4method{fsMrmre}{ExprsBinary}(object, probes, ...)

\S4method{fsSample}{ExprsMulti}(object, probes, ...)

\S4method{fsStats}{ExprsMulti}(object, probes, ...)
}
\arguments{
\item{object}{Specifies the \code{ExprsArray} object to undergo feature selection.}

\item{...}{Arguments passed to the respective wrapped function.}

\item{probes}{A numeric scalar or character vector. A numeric scalar indicates
the number of top features that should undergo feature selection. A character vector
indicates specifically which features by name should undergo feature selection.
Set \code{probes = 0} to include all features.}

\item{how}{Specifics which function to call in \code{fsStats}. Accepted arguments
include \code{"t.test"}, \code{"ks.test"}, and \code{"ks.boot"}.}
}
\value{
Returns an \code{ExprsArray} object.
}
\description{
A collection of functions to select features.
}
\details{
Considering the high-dimensionality of most genomic datasets, it is prudent and often necessary
 to prioritize which features to include during classifier construction. There exists a myriad of
 ways to perform the task of feature selection. This package provides methods for some of the most
 frequently used feature selection methods. Each function works as a self-contained wrapper that
 (1) pre-processes the ExprsArray input, (2) performs the feature selection, and (3) returns an
 ExprsArray output with an updated feature selection history. The user may deploy, in tandem, any
 number of these functions in whatever order they choose, limited only by computational power and
 imagination. These feature selection histories get passed along at every step of the way until
 they eventually get used in order to pre-process an unlabelled dataset during classifier deployment
 (i.e. prediction). In the spirit of open source programming, we encourage users to submit their
 own feature selection functions, modeled after those provided in this library.

All feature selection methods here perform feature selection prior to classifier construction. For
 \code{ExprsBinary} methods, this is typically the desired approach. However, the exprso package
 also provides \code{\link{pl}} methods which automate integrated machine learning pipelines.
 However, these feature selection methods do not necessarily generalize to multi-class classification.
 As such, the \code{ExprsMulti} methods instead harness the \code{\link{doMulti}} function
 to perform "1 vs. all" binary feature selection, aggregating the final results with
 \code{\link{reRank}}. A better approach would perform "1 vs. all" feature selection and classifier
 construction simultaneously, rather than "1 vs. all" feature selection followed by "1 vs. all"
 classifier construction. We hope to provide a \code{pl} method for this in the future.

For all feature selection methods, \code{@preFilter} and \code{@reductionModel} stores the
 feature selection and dimension reduction history, respectively. This history gets passed
 along to prepare the test or validation set during model deployment, ensuring that these
 sets undergo the same feature selection and dimension reduction in the appropriate steps.
 Under the scenarios where users plan to apply multiple feature selection or dimension
 reduction steps, the \code{probes} argument manages which features (e.g. gene probes) to
 send through each feature selection or dimension reduction procedure. For \code{probes},
 a numeric scalar indicates the number of top features to use, while a character vector
 indicates specifically which features to use. In this way, the user sets which features
 to feed INTO the \code{fs} method (NOT which features the user expects OUT). The example
 below shows how to apply dimension reduction to the top 50 features as selected by the
 Student's t-test. Set \code{probes = 0} to pass all features through an \code{fs} method.

Note that \code{fsMrmre} crashes when supplied a very large \code{feature_count} argument
 owing to its implementation in the imported package \code{mRMRe}.
}
\section{Methods (by generic)}{

\code{fsSample:} Method to perform random feature selection using base::sample.


\code{fsStats:} Method to perform statistics based feature selection using stats::t.test and others.


\code{fsPrcomp:} Method to perform principal components analysis using stats::prcomp.


\code{fsPenalizedSVM:} Method to perform penalizedSVM feature selection using penalizedSVM::svm.fs.


\code{fsPathClassRFE:} Method to perform SVM-RFE feature selection using pathClass::fit.rfe.


\code{fsEbayes:} Method to perform empiric Bayes feature selection using limma::ebayes.


\code{fsMrme:} Method to perform mRMR feature selection using mRMRe::mRMR.classic.
}
\examples{
\dontrun{
library(golubEsets)
data(Golub_Merge)
array <- arrayEset(Golub_Merge, colBy = "ALL.AML", include = list("ALL", "AML"))
array <- modFilter(array, 20, 16000, 500, 5) # pre-filter Golub ala Deb 2003
array <- modTransform(array) # lg transform
array <- modNormalize(array, c(1, 2)) # normalize gene and subject vectors
arrays <- splitSample(array, percent.include = 67)
array.train <- fsStats(arrays[[1]], probes = 0, how = "t.test")
array.train <- fsPrcomp(array.train, probes = 50)
mach <- buildSVM(array.train, probes = 5, kernel = "linear", cost = 1)
}
}
\seealso{
\code{\link{fs}}\cr
\code{\link{build}}\cr
\code{\link{doMulti}}\cr
\code{\link{reRank}}\cr
\code{\link{exprso-predict}}\cr
\code{\link{plCV}}\cr
\code{\link{plGrid}}\cr
\code{\link{plMonteCarlo}}\cr
\code{\link{plNested}}
}

